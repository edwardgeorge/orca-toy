@op-ascii
	( 21	! ) :op-null
	( 22	" ) :op-null
	( 23	# ) :op-comment
	( 24	$ ) :op-self
	( 25	% ) :op-null
	( 26	& ) :op-null
	( 27	' ) :op-null
	( 28	( ) :op-null
	( 29	) ) :op-null
	( 2A	* ) :op-bang
	( 2B	+ ) :op-null
	( 2C	, ) :op-null
	( 2D	- ) :op-null
	( 2E	. ) :op-null
	( 2F	/ ) :op-null
	( 30	0 ) :op-null
	( 31	1 ) :op-null
	( 32	2 ) :op-null
	( 33	3 ) :op-null
	( 34	4 ) :op-null
	( 35	5 ) :op-null
	( 36	6 ) :op-null
	( 37	7 ) :op-null
	( 38	8 ) :op-null
	( 39	9 ) :op-null
	( 3A	: ) :op-midi
	( 3B	; ) :op-pitch
	( 3C	< ) :op-null
	( 3D	= ) :op-synth
	( 3E	> ) :op-null
	( 3F	? ) :op-null
	( 40	@ ) :op-null
	( 41	A ) :op-a
	( 42	B ) :op-b
	( 43	C ) :op-b
	( 44	D ) :op-d
	( 45	E ) :op-e
	( 46	F ) :op-f
	( 47	G ) :op-g
	( 48	H ) :op-h
	( 49	I ) :op-i
	( 4A	J ) :op-j
	( 4B	K ) :op-k
	( 4C	L ) :op-l
	( 4D	M ) :op-m
	( 4E	N ) :op-n
	( 4F	O ) :op-o
	( 50	P ) :op-p
	( 51	Q ) :op-q
	( 52	R ) :op-r
	( 53	S ) :op-s
	( 54	T ) :op-t
	( 55	U ) :op-u
	( 56	V ) :op-v
	( 57	W ) :op-w
	( 58	X ) :op-x
	( 59	Y ) :op-x
	( 5A	Z ) :op-z
	( 5B	[ ) :op-null
	( 5C	\ ) :op-null
	( 5D	] ) :op-null
	( 5E	^ ) :op-null
	( 5F	_ ) :op-null
	( 60	` ) :op-null
	( 61	a ) :op-a-lc
	( 62	b ) :op-b-lc
	( 63	c ) :op-b-lc
	( 64	d ) :op-d-lc
	( 65	e ) :op-e-lc
	( 66	f ) :op-f-lc
	( 67	g ) :op-g-lc
	( 68	h ) :op-h-lc
	( 69	i ) :op-i-lc
	( 6A	j ) :op-j-lc
	( 6B	k ) :op-k-lc
	( 6C	l ) :op-l-lc
	( 6D	m ) :op-m-lc
	( 6E	n ) :op-n-lc
	( 6F	o ) :op-o-lc
	( 70	p ) :op-p-lc
	( 71	q ) :op-q-lc
	( 72	r ) :op-r-lc
	( 73	s ) :op-s-lc
	( 74	t ) :op-t-lc
	( 75	u ) :op-u-lc
	( 76	v ) :op-v-lc
	( 77	w ) :op-w-lc
	( 78	x ) :op-x-lc
	( 79	y ) :op-y-lc
	( 7A	z ) :op-z-lc
	( 7B	{ ) :op-null
	( 7C	| ) :op-null
	( 7D	} ) :op-null
	( 7E	~ ) :op-null
	( 7F	 ) :op-null

@op-table
	&docs
	:op-a :op-b :op-c :op-d :op-e :op-f :op-g :op-h
	:op-i :op-j :op-k :op-l :op-m :op-n :op-o :op-p
	:op-q :op-r :op-s :op-t :op-u :op-v :op-w :op-x
	:op-y :op-z
	:op-bang :op-comment :op-synth :op-midi :op-pitch :op-byte :op-self
	&func
	:op-a/func :op-b/func :op-c/func :op-d/func :op-e/func :op-f/func :op-g/func :op-h/func
	:op-i/func :op-j/func :op-k/func :op-l/func :op-m/func :op-n/func :op-o/func :op-p/func
	:op-q/func :op-r/func :op-s/func :op-t/func :op-u/func :op-v/func :op-w/func :op-x/func
	:op-y/func :op-z/func

@op-a-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-a ( add )
	'A "Outputs 20 "sum 20 "of 20 "inputs $1
	&func ( addr* -- )

	STH2k
	( a-val ) #0001 SUB2 ;get-port-left-value JSR2
	( b-raw ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2
	( res ) ADD
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-b-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-b ( subtract )
	'B "Outputs 20 "difference 20 "of 20 "inputs $1
	&func ( addr* -- )

	STH2k
	( get a ) #0001 SUB2 ;get-port-left-value JSR2
	( get b ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2
	( res ) SUB DUP #80 LTH ,&bounce JCN #24 SWP SUB &bounce
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-c-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-c ( clock )
	'C "Outputs 20 "modulo 20 "of 20 "frame $1
	&func ( addr* -- )

	STH2k
	( get rate ) #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
	( get mod ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2 DUP #00 EQU ADD
	( res ) #00 SWP ROT #00 SWP .timer/frame LDZ2 SWP2 DIV2 SWP2 DIV2k MUL2 SUB2 NIP
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-d-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-d ( delay )
	'D "Bangs 20 "on 20 "modulo 20 "of 20 "frame $1
	&func ( addr* -- )

	STH2k
	( get rate ) #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
	( get mod ) STH2kr INC2 ;get-port-right-value JSR2 DUP #00 EQU ADD
	( res ) MUL #00 SWP .timer/frame LDZ2 SWP2 DIV2k MUL2 SUB2 #0000 EQU2
	( bang on equal ) #fc MUL LIT '. ADD
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-e-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-e ( east )
	'E "Moves 20 "eastward 20 "or 20 "bangs $1
	&func ( addr* -- )

	STH2k ;data/cells ADD2 LDA ,&self STR
	( wall ) .head/x LDZ INC .grid/width LDZ EQU ,&collide JCN
	( cell ) STH2kr INC2 ;data/cells ADD2 LDA LIT '. NEQ ,&collide JCN
	( write new ) [ LIT &self $1 ] STH2kr INC2 ;set-port-raw JSR2
	( erase old ) LIT '. STH2r ;set-port-raw JSR2
	JMP2r
	&collide
	( output ) LIT '* STH2r ;set-port-output JSR2

JMP2r

@op-f-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-f ( if )
	'F "Bangs 20 "if 20 "inputs 20 "are 20 "equal $1
	&func ( addr* -- )

	STH2k
	( get a ) #0001 SUB2 ;get-port-left-raw JSR2
	( get b ) STH2kr INC2 ;get-port-right-raw JSR2
	( bang on equal ) EQU [ #fc MUL LIT '. ADD ]
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-g-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-g ( generator )
	'G "Writes 20 "operands 20 "with 20 "offset $1
	&func ( addr* -- )

	STH2k
	( x ) STH2kr #0003 SUB2 ;get-port-left-value JSR2
		( load ) #00 SWP ADD2
	( y ) STH2kr #0002 SUB2 ;get-port-left-value JSR2
		( load ) #00 SWP INC2 [ #00 .grid/width LDZ MUL2 ] ADD2
	,&save STR2
	( len ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
	#00
	&loop
		( load ) #00 OVR STH2kr INC2 ADD2 ;get-port-right-raw JSR2
		( save ) OVR #00 SWP [ LIT2 &save $2 ] ADD2 ;set-port-output JSR2
		INC GTHk ,&loop JCN
	POP2
	POP2r

JMP2r

@op-h-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-h ( hold )
	'H "Holds 20 "southward 20 "operand $1
	&func ( addr* -- )

	#00 .grid/width LDZ ADD2
	( set lock ) DUP2 #01 ROT ROT ;data/locks ADD2 STA
	( set type ) OUTPUT-TYPE ROT ROT ;data/types ADD2 STA

JMP2r

@op-i-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-i ( increment )
	'I "Increments 20 "southward 20 "operand $1
	&func ( addr* -- )

	STH2k
	( step ) #0001 SUB2 ;get-port-left-value JSR2
	( mod ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2 DUP #00 EQU ADD
	( res ) SWP STH2kr #00 .grid/width LDZ ADD2 [ ;data/cells ADD2 LDA ;chrb36 JSR2 ] ADD SWP DIVk MUL SUB
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-j-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-j ( jumper )
	'J "Outputs 20 "northward 20 "operand $1
	&func ( addr* -- )

	STH2k
	( get above ) #00 .grid/width LDZ SUB2 ;get-port-left-raw JSR2
	( ignore cable )
	DUP ;chrb36 JSR2 #13 NEQ ,&no-wire JCN
		POP POP2r JMP2r &no-wire
	( skip down )
	STH2r
	&while
		#00 .grid/width LDZ ADD2 DUP2 ;data/cells ADD2 LDA ;chrb36 JSR2 #13 EQU
		,&while JCN
	( set below ) ;set-port-output JSR2

JMP2r

@op-k-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-k ( konkat )
	'K "Reads 20 "multiple 20 "variables $1
	&func ( addr* -- )

	STH2k
	#0001 SUB2 ;get-port-left-value JSR2 #00
	&loop
		#00 OVR STH2kr INC2 ADD2 STH2k ;get-port-right-raw JSR2
		DUP LIT '. EQU ,&skip JCN
			( load ) DUP ;chrb36 JSR2 .variables ADD LDZ
			( save ) STH2kr #00 .grid/width LDZ ADD2 ;set-port-output JSR2
			&skip
		POP
		POP2r
		INC GTHk ;&loop JCN2
	POP2
	POP2r

JMP2r

@op-l-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-l ( lesser )
	'L "Outputs 20 "smallest 20 "of 20 "inputs $1
	&func ( addr* -- )

	STH2k
	( get a ) #0001 SUB2 ;get-port-left-value JSR2
	( get b ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2
	( res ) [ LTHk JMP SWP POP ]
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-m-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-m ( multiply )
	'M "Outputs 20 "product 20 "of 20 "inputs $1
	&func ( addr* -- )

	STH2k
	( get a ) #0001 SUB2 ;get-port-left-value JSR2
	( get b ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2
	( res ) MUL
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-n-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-n ( north )
	'N "Moves 20 "Northward 20 "or 20 "bangs $1
	&func ( addr* -- )

	STH2k ;data/cells ADD2 LDA ,&self STR
	( wall ) .head/y LDZ #01 SUB #ff EQU ,&collide JCN
	( cell ) STH2kr #00 .grid/width LDZ SUB2 ;data/cells ADD2 LDA LIT '. NEQ ,&collide JCN
	( write new ) [ LIT &self $1 ] STH2kr #00 .grid/width LDZ SUB2 ;set-port-raw JSR2
	( erase old ) LIT '. STH2r ;set-port-raw JSR2
	JMP2r
	&collide
	( output ) LIT '* STH2r ;set-port-output JSR2

JMP2r

@op-o-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-o ( read )
	'O "Reads 20 "operand 20 "with 20 "offset $1
	&func ( addr* -- )

	STH2k
	( x ) STH2kr #0002 SUB2 ;get-port-left-value JSR2 INC #00 SWP ADD2
	( y ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 #00 SWP #00 .grid/width LDZ MUL2 ADD2
	( val ) ;get-port-right-raw JSR2
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-p-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-p ( push )
	'P "Writes 20 "eastward 20 "operand $1
	&func ( addr* -- )

	STH2k
	( key ) #0002 SUB2 ;get-port-left-value JSR2
	( len ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
	#00
	&loop
		#00 OVR STH2kr #00 .grid/width LDZ ADD2 ADD2 STH2
		( lock ) #01 STH2kr ;data/locks ADD2 STA
		( type ) LOCKED-TYPE STH2r ;data/types ADD2 STA
		INC GTHk ,&loop JCN
	POP
	( read ) STH2kr INC2 ;get-port-right-raw JSR2
	( output ) ROT ROT DIVk MUL SUB #00 SWP STH2r #00 .grid/width LDZ ADD2 ADD2 ;set-port-output JSR2

JMP2r

@op-q-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-q ( query )
	'Q "Reads 20 "operands 20 "with 20 "offset $1
	&func ( addr* -- )

	STH2k
	( x ) STH2kr #0003 SUB2 ;get-port-left-value JSR2
		( load ) #00 SWP INC2 ADD2
	( y ) STH2kr #0002 SUB2 ;get-port-left-value JSR2
		( load ) #00 SWP [ #00 .grid/width LDZ MUL2 ] ADD2
	,&load STR2
	( len ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
		( save ) #00 OVR STH2kr #00 .grid/width LDZ ADD2 SWP2 SUB2 INC2 ,&save STR2
	#00
	&loop
		( load ) #00 OVR [ LIT2 &load $2 ] ADD2 ;get-port-right-raw JSR2
		( save ) OVR #00 SWP [ LIT2 &save $2 ] ADD2 ;set-port-output JSR2
		INC GTHk ,&loop JCN
	POP2
	POP2r

JMP2r

@op-r-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-r ( random )
	'R "Outputs 20 "random 20 "value $1
	&func ( addr* -- )

	STH2k
	( a-min ) #0001 SUB2 ;get-port-left-value JSR2
	( b-max ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2 DUP #00 EQU ADD
	( mod ) OVR SUB ;prng JSR2 ADD SWP DUP #00 EQU ADD DIVk MUL SUB ADD
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-s-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-s ( south )
	'S "Moves 20 "southward 20 "or 20 "bangs $1
	&func ( addr* -- )

	STH2k ;data/cells ADD2 LDA ,&self STR
	( wall ) .head/y LDZ INC .grid/height LDZ EQU ,&collide JCN
	( cell ) STH2kr #00 .grid/width LDZ ADD2 ;data/cells ADD2 LDA LIT '. NEQ ,&collide JCN
	( write new ) [ LIT &self $1 ] STH2kr #00 .grid/width LDZ ADD2 ;set-port-raw JSR2
	( erase old ) LIT '. STH2r ;set-port-raw JSR2
	JMP2r
	&collide
	( output ) LIT '* STH2r ;set-port-output JSR2

JMP2r

@op-t-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-t ( track )
	'T "Reads 20 "eastward 20 "operand $1
	&func ( addr* -- )

	STH2k
	( key ) #0002 SUB2 ;get-port-left-value JSR2
	( len ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
	#00
	&loop
		#00 OVR STH2kr INC2 ADD2 STH2
		( lock ) #01 STH2kr ;data/locks ADD2 STA
		( type ) LOCKED-TYPE STH2r ;data/types ADD2 STA
		INC GTHk ,&loop JCN
	POP
	( read ) DIVk MUL SUB #00 SWP STH2kr INC2 ADD2 ;get-port-right-raw JSR2
	STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-u-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-u ( Uclid )
	'U "Bangs 20 "on 20 "Euclidean 20 "rhythm $1
	&func ( addr* -- )

	STH2k
	( step ) #0001 SUB2 ;get-port-left-value JSR2
	( max ) STH2kr INC2 ;get-port-right-value JSR2 DUP #00 EQU ADD STH2
	( frame ADD max SUB 1 ) .timer/frame LDZ2 STHkr #00 SWP ADD2 #0001 SUB2
	( MUL step ) OVRr STHr #00 SWP MUL2
	( % max ) STHkr #00 SWP DIV2k MUL2 SUB2
	( ADD step ) SWPr STHr #00 SWP ADD2
	( bucket GTH= max ) STHr #00 SWP LTH2 #01 NEQ
	( bang if equal ) #fc MUL LIT '. ADD
	STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-v-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-v ( variable )
	'V "Reads 20 "and 20 "writes 20 "variable $1
	&func ( addr* -- )

	STH2k
	( key ) #0001 SUB2 ;get-port-left-raw JSR2
	( val ) STH2kr INC2 ;get-port-right-raw JSR2
	DUP LIT '. EQU ,&idle JCN
	OVR ;chrb36 JSR2 ,&save JCN
	( load )
		NIP ;chrb36 JSR2 .variables ADD LDZ STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2 JMP2r
	&save
		SWP ;chrb36 JSR2 .variables ADD STZ POP2r JMP2r
	&idle
		POP2 POP2r

JMP2r

@op-w-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-w ( west )
	'W "Moves 20 "westward 20 "or 20 "bangs $1
	&func ( addr* -- )

	STH2k ;data/cells ADD2 LDA ,&self STR
	( wall ) .head/x LDZ #01 SUB #ff EQU ,&collide JCN
	( cell ) STH2kr #0001 SUB2 ;data/cells ADD2 LDA LIT '. NEQ ,&collide JCN
	( write new ) [ LIT &self $1 ] STH2kr #0001 SUB2 ;set-port-raw JSR2
	( erase old ) LIT '. STH2r ;set-port-raw JSR2
	JMP2r
	&collide
	( output ) LIT '* STH2r ;set-port-output JSR2

JMP2r

@op-x-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-x ( write )
	'X "Writes 20 "operand 20 "with 20 "offset $1
	&func ( addr* -- )

	STH2k
	( x ) STH2kr #0002 SUB2 ;get-port-left-value JSR2 #00 SWP ADD2
	( y ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 INC #00 SWP #00 .grid/width LDZ MUL2 ADD2
	( val ) STH2r INC2 ;get-port-right-raw JSR2
	( output ) ROT ROT ;set-port-output JSR2

JMP2r

@op-y-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-y ( yumper )
	'Y "Outputs 20 "westward 20 "operand $1
	&func ( addr* -- )

	STH2k
	( get above ) #0001 SUB2 ;get-port-left-raw JSR2
	( ignore cable )
	DUP ;chrb36 JSR2 #22 NEQ ,&no-wire JCN
		POP POP2r JMP2r &no-wire
	( skip down )
	STH2r
	&while
		INC2 DUP2 ;data/cells ADD2 LDA ;chrb36 JSR2 #22 EQU
		,&while JCN
	( set below ) ;set-port-output JSR2

JMP2r

@op-z-lc ;get-bang JSR2 ,&* POP JMP2r &*
@op-z ( lerp )
	'Z "Transitions 20 "operand 20 "to 20 "input $1
	&func ( addr* -- )

	STH2k
	( rate ) #0001 SUB2 ;get-port-left-value JSR2
	( target ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2
	( val ) STH2kr #00 .grid/width LDZ ADD2 [ ;data/cells ADD2 LDA ;chrb36 JSR2 ]
	( res ) ;lerp JSR2
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

( special )

@op-bang ( bang )
	'* "Bangs 20 "neighboring 20 "operands $1
	&func ( char -- )

	POP
	LIT '. .head/addr LDZ2 ;data/cells ADD2 STA

JMP2r

@op-comment ( comment )
	'# "Comments 20 "a 20 "line $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	( bounds )
	#00 .grid/width LDZ .head/x LDZ SUB ADD2
	STH2r INC2
	&loop
		( set lock ) DUP2 #01 ROT ROT ;data/locks ADD2 STA
		( set type if unset )
		DUP2 ;data/types ADD2 LDA ,&skip JCN
			( set type ) DUP2 LOCKED-TYPE ROT ROT ;data/types ADD2 STA
			&skip
		( stop at hash ) DUP2 ;data/cells ADD2 LDA LIT '# EQU ,&end JCN
		INC2 GTH2k ,&loop JCN
	&end
	POP2 POP2

JMP2r

@op-synth ( synth )
	'= "Play 20 "note 20 "with 20 "uxn 20 "synth $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	( channel ) INC2 ;get-port-right-value JSR2 [ ,&ch STR ]
	( octave ) STH2kr INC2 INC2 ;get-port-right-value JSR2
	( note ) STH2kr #0003 ADD2 ;get-port-right-raw JSR2
	( has note ) DUP LIT '. NEQ ,&has-note JCN [ POP2 POP2r JMP2r ] &has-note
	( has bang ) ;get-bang JSR2 ,&is-bang JCN [ POP2 POP2r JMP2r ] &is-bang
	( animate ) IO-TYPE STH2r ;data/types ADD2 STA
	( get note ) ;chrmid JSR2 SWP [ #0c MUL ] ADD
	( play ) .Audio0/pitch [ LIT &ch $1 ] #03 AND #40 SFT ADD DEO

JMP2r

@op-midi ( midi )
	': "Send 20 "a 20 "midi 20 "note $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	( channel ) INC2 ;get-port-right-value JSR2 [ ,&ch STR ]
	( octave ) STH2kr INC2 INC2 ;get-port-right-value JSR2
	( note ) STH2kr #0003 ADD2 ;get-port-right-raw JSR2
	( velocity ) STH2kr #0004 ADD2 ;get-port-right-raw JSR2 [ ,&vel STR ]
	( length ) STH2kr #0005 ADD2 ;get-port-right-value JSR2

	( has note ) OVR LIT '. NEQ ,&has-note JCN [ POP POP2 POP2r JMP2r ] &has-note
	( has bang ) ;get-bang JSR2 ,&is-bang JCN [ POP POP2 POP2r JMP2r ] &is-bang

	( store length ) .voices ,&ch LDR DUP ADD ADD INC STZk POP [ ,&len STR ]

	( animate ) IO-TYPE STH2r ;data/types ADD2 STA

	( get note ) ;chrmid JSR2 SWP [ #0c MUL ] ADD
	( store note ) DUP .voices ,&ch LDR DUP ADD ADD STZ
	( get velocity ) [ LIT &vel $1 ]
		DUP LIT '. NEQ ,&normalize JCN
			( default to max ) POP #7f ,&continue JMP
		&normalize
		;raw-to-b128 JSR2 &continue SWP
	( get channel ) [ LIT &ch $1 ]

	( note on )
	( channel ) DUP .Console/write DEO
	( note ) OVR .Console/write DEO
	( velocity ) ROT .Console/write DEO

	.signal/midi LDZk INC SWP STZ

	( note off immediately if 0 length )
	[ LIT &len $1 ] #00 NEQ ,&done JCN
		( channel ) .Console/write DEO
		( note ) .Console/write DEO
		( off ) #00 .Console/write DEO
		JMP2r
	&done
	POP2

JMP2r

@op-pitch ( pitch )
	'; "Send 20 "a 20 "raw 20 "pitch 20 "byte $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	( octave ) INC2 ;get-port-right-value JSR2
	( note ) STH2kr INC2 INC2 ;get-port-right-raw JSR2
	( has note ) DUP LIT '. NEQ ,&has-note JCN [ POP2 POP2r JMP2r ] &has-note
	( has bang ) ;get-bang JSR2 ,&is-bang JCN [ POP2 POP2r JMP2r ] &is-bang
	( animate ) IO-TYPE STH2r ;data/types ADD2 STA
	( get note ) ;chrmid JSR2 SWP [ #0c MUL ] ADD .Console/write DEO

JMP2r

@op-byte ( byte )
	'/ "Send 20 "a 20 "raw 20 "hexadecimal 20 "byte $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	( hn ) INC2 ;get-port-right-value JSR2
	( ln ) STH2kr INC2 INC2 ;get-port-right-value JSR2
	( has bang ) ;get-bang JSR2 ,&is-bang JCN [ POP2 POP2r JMP2r ] &is-bang
	( animate ) IO-TYPE STH2r ;data/types ADD2 STA
	#0f AND SWP #0f AND #40 SFT ADD .Console/write DEO

JMP2r

@op-self ( self )
	'$ "Load 20 "orca 20 "file $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	&while
		INC2 DUP2 ;get-port-right-raw JSR2 LIT '. NEQ ,&while JCN
	POP2
	( has bang ) ;get-bang JSR2 ,&is-bang JCN [ POP2r JMP2r ] &is-bang
	.head LDZ2 INC STH2kr ;get-word JSR2 ;inject-file JSR2
	( animate ) IO-TYPE STH2r ;data/types ADD2 STA

JMP2r

@op-null ( null )
	&func ( char -- )

	POP

JMP2r

