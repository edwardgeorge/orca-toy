@op-table
	&docs
	:op-a :op-b :op-c :op-d :op-e :op-f :op-g :op-h
	:op-i :op-j :op-k :op-l :op-m :op-n :op-o :op-p
	:op-q :op-r :op-s :op-t :op-u :op-v :op-w :op-x
	:op-y :op-z
	:op-bang :op-comment :op-synth :op-midi :op-pitch :op-byte :op-self
	&func
	:op-a/func :op-b/func :op-c/func :op-d/func :op-e/func :op-f/func :op-g/func :op-h/func
	:op-i/func :op-j/func :op-k/func :op-l/func :op-m/func :op-n/func :op-o/func :op-p/func
	:op-q/func :op-r/func :op-s/func :op-t/func :op-u/func :op-v/func :op-w/func :op-x/func
	:op-y/func :op-z/func

@op-a ( add )
	'A "Outputs 20 "sum 20 "of 20 "inputs $1
	&func ( addr* -- )

	STH2k
	( a-val ) #0001 SUB2 ;get-port-left-value JSR2
	( b-raw ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2
	( res ) ADD
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-b ( subtract )
	'B "Outputs 20 "difference 20 "of 20 "inputs $1
	&func ( addr* -- )

	STH2k
	( get a ) #0001 SUB2 ;get-port-left-value JSR2
	( get b ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2
	( res ) SUB DUP #80 LTH ,&bounce JCN #24 SWP SUB &bounce
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-c ( clock )
	'C "Outputs 20 "modulo 20 "of 20 "frame $1
	&func ( addr* -- )

	STH2k
	( get rate ) #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
	( get mod ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2 DUP #00 EQU ADD
	( res ) #00 SWP ROT #00 SWP .timer/frame LDZ2 SWP2 DIV2 SWP2 DIV2k MUL2 SUB2 NIP
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-d ( delay )
	'D "Bangs 20 "on 20 "modulo 20 "of 20 "frame $1
	&func ( addr* -- )

	STH2k
	( get rate ) #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
	( get mod ) STH2kr INC2 ;get-port-right-value JSR2 DUP #00 EQU ADD
	( res ) MUL #00 SWP .timer/frame LDZ2 SWP2 DIV2k MUL2 SUB2 #0000 EQU2
	( bang on equal ) #fc MUL CHAR-DOT ADD
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-e ( east )
	'E "Moves 20 "eastward 20 "or 20 "bangs $1
	&func ( addr* -- )

	STH2k ;data/cells ADD2 LDA ,&self STR
	( wall ) .head/x LDZ INC .grid/width LDZ EQU ,&collide JCN
	( cell ) STH2kr INC2 ;data/cells ADD2 LDA CHAR-DOT NEQ ,&collide JCN
	( write new ) [ LIT &self $1 ] STH2kr INC2 ;set-port-raw JSR2
	( erase old ) CHAR-DOT STH2r ;set-port-raw JSR2
	JMP2r
	&collide
	( output ) CHAR-BANG STH2r ;set-port-output JSR2

JMP2r

@op-f ( if )
	'F "Bangs 20 "if 20 "inputs 20 "are 20 "equal $1
	&func ( addr* -- )

	STH2k
	( get a ) #0001 SUB2 ;get-port-left-raw JSR2
	( get b ) STH2kr INC2 ;get-port-right-raw JSR2
	( bang on equal ) EQU [ #fc MUL CHAR-DOT ADD ]
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-g ( generator )
	'G "Writes 20 "operands 20 "with 20 "offset $1
	&func ( addr* -- )

	STH2k
	( x ) STH2kr #0003 SUB2 ;get-port-left-value JSR2
		( load ) #00 SWP ADD2
	( y ) STH2kr #0002 SUB2 ;get-port-left-value JSR2
		( load ) #00 SWP INC2 [ #00 .grid/width LDZ MUL2 ] ADD2
	,&save STR2
	( len ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
	#00
	&loop
		( load ) DUP #00 SWP STH2kr INC2 ADD2 ;get-port-right-raw JSR2
		( save ) OVR #00 SWP [ LIT2 &save $2 ] ADD2 ;set-port-output JSR2
		INC GTHk ,&loop JCN
	POP2
	POP2r

JMP2r

@op-h ( hold )
	'H "Holds 20 "southward 20 "operand $1
	&func ( addr* -- )

	#00 .grid/width LDZ ADD2
	( set lock ) DUP2 #01 ROT ROT ;data/locks ADD2 STA
	( set type ) OUTPUT-TYPE ROT ROT ;data/types ADD2 STA

JMP2r

@op-i ( increment )
	'I "Increments 20 "southward 20 "operand $1
	&func ( addr* -- )

	STH2k
	( step ) #0001 SUB2 ;get-port-left-value JSR2
	( mod ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2 DUP #00 EQU ADD
	( res ) SWP STH2kr #00 .grid/width LDZ ADD2 [ ;data/cells ADD2 LDA ;chrb36 JSR2 ] ADD SWP DIVk MUL SUB
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-j ( jumper )
	'J "Outputs 20 "northward 20 "operand $1
	&func ( addr* -- )

	STH2k
	( get above ) #00 .grid/width LDZ SUB2 ;get-port-left-raw JSR2
	( ignore cable )
	DUP ;chrb36 JSR2 #13 NEQ ,&no-wire JCN
		POP POP2r JMP2r &no-wire
	( skip down )
	STH2r
	&while
		#00 .grid/width LDZ ADD2 DUP2 ;data/cells ADD2 LDA ;chrb36 JSR2 #13 EQU
		,&while JCN
	( set below ) ;set-port-output JSR2

JMP2r

@op-k ( konkat )
	'K "Reads 20 "multiple 20 "variables $1
	&func ( addr* -- )

	STH2k
	#0001 SUB2 ;get-port-left-value JSR2 #00
	&loop
		DUP #00 SWP STH2kr INC2 ADD2 STH2k ;get-port-right-raw JSR2
		DUP CHAR-DOT EQU ,&skip JCN
			( load ) DUP ;chrb36 JSR2 .variables ADD LDZ
			( save ) STH2kr #00 .grid/width LDZ ADD2 ;set-port-output JSR2
			&skip
		POP
		POP2r
		INC GTHk ;&loop JCN2
	POP2
	POP2r

JMP2r

@op-l ( lesser )
	'L "Outputs 20 "smallest 20 "of 20 "inputs $1
	&func ( addr* -- )

	STH2k
	( get a ) #0001 SUB2 ;get-port-left-value JSR2
	( get b ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2
	( res ) [ LTHk JMP SWP POP ]
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-m ( multiply )
	'M "Outputs 20 "product 20 "of 20 "inputs $1
	&func ( addr* -- )

	STH2k
	( get a ) #0001 SUB2 ;get-port-left-value JSR2
	( get b ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2
	( res ) MUL
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-n ( north )
	'N "Moves 20 "Northward 20 "or 20 "bangs $1
	&func ( addr* -- )

	STH2k ;data/cells ADD2 LDA ,&self STR
	( wall ) .head/y LDZ #01 SUB #ff EQU ,&collide JCN
	( cell ) STH2kr #00 .grid/width LDZ SUB2 ;data/cells ADD2 LDA CHAR-DOT NEQ ,&collide JCN
	( write new ) [ LIT &self $1 ] STH2kr #00 .grid/width LDZ SUB2 ;set-port-raw JSR2
	( erase old ) CHAR-DOT STH2r ;set-port-raw JSR2
	JMP2r
	&collide
	( output ) CHAR-BANG STH2r ;set-port-output JSR2

JMP2r

@op-o ( read )
	'O "Reads 20 "operand 20 "with 20 "offset $1
	&func ( addr* -- )

	STH2k
	( x ) STH2kr #0002 SUB2 ;get-port-left-value JSR2 INC #00 SWP ADD2
	( y ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 #00 SWP #00 .grid/width LDZ MUL2 ADD2
	( val ) ;get-port-right-raw JSR2
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-p ( push )
	'P "Writes 20 "eastward 20 "operand $1
	&func ( addr* -- )

	STH2k
	( key ) #0002 SUB2 ;get-port-left-value JSR2
	( len ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
	#00
	&loop
		#00 OVR STH2kr #00 .grid/width LDZ ADD2 ADD2 STH2
		( lock ) #01 STH2kr ;data/locks ADD2 STA
		( type ) LOCKED-TYPE STH2r ;data/types ADD2 STA
		INC GTHk ,&loop JCN
	POP
	( read ) STH2kr INC2 ;get-port-right-raw JSR2
	( output ) ROT ROT DIVk MUL SUB #00 SWP STH2r #00 .grid/width LDZ ADD2 ADD2 ;set-port-output JSR2

JMP2r

@op-q ( query )
	'Q "Reads 20 "operands 20 "with 20 "offset $1
	&func ( addr* -- )

	STH2k
	( x ) STH2kr #0003 SUB2 ;get-port-left-value JSR2
		( load ) #00 SWP INC2 ADD2
	( y ) STH2kr #0002 SUB2 ;get-port-left-value JSR2
		( load ) #00 SWP [ #00 .grid/width LDZ MUL2 ] ADD2
	,&load STR2
	( len ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
		( save ) DUP #00 SWP STH2kr #00 .grid/width LDZ ADD2 SWP2 SUB2 INC2 ,&save STR2
	#00
	&loop
		( load ) DUP #00 SWP [ LIT2 &load $2 ] ADD2 ;get-port-right-raw JSR2
		( save ) OVR #00 SWP [ LIT2 &save $2 ] ADD2 ;set-port-output JSR2
		INC GTHk ,&loop JCN
	POP2
	POP2r

JMP2r

@op-r ( random )
	'R "Outputs 20 "random 20 "value $1
	&func ( addr* -- )

	STH2k
	( a-min ) #0001 SUB2 ;get-port-left-value JSR2
	( b-max ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2 DUP #00 EQU ADD
	( mod ) OVR SUB ;prng JSR2 ADD SWP DUP #00 EQU ADD DIVk MUL SUB ADD
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-s ( south )
	'S "Moves 20 "southward 20 "or 20 "bangs $1
	&func ( addr* -- )

	STH2k ;data/cells ADD2 LDA ,&self STR
	( wall ) .head/y LDZ INC .grid/height LDZ EQU ,&collide JCN
	( cell ) STH2kr #00 .grid/width LDZ ADD2 ;data/cells ADD2 LDA CHAR-DOT NEQ ,&collide JCN
	( write new ) [ LIT &self $1 ] STH2kr #00 .grid/width LDZ ADD2 ;set-port-raw JSR2
	( erase old ) CHAR-DOT STH2r ;set-port-raw JSR2
	JMP2r
	&collide
	( output ) CHAR-BANG STH2r ;set-port-output JSR2

JMP2r

@op-t ( track )
	'T "Reads 20 "eastward 20 "operand $1
	&func ( addr* -- )

	STH2k
	( key ) #0002 SUB2 ;get-port-left-value JSR2
	( len ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 DUP #00 EQU ADD
	#00
	&loop
		#00 OVR STH2kr INC2 ADD2 STH2
		( lock ) #01 STH2kr ;data/locks ADD2 STA
		( type ) LOCKED-TYPE STH2r ;data/types ADD2 STA
		INC GTHk ,&loop JCN
	POP
	( read ) DIVk MUL SUB #00 SWP STH2kr INC2 ADD2 ;get-port-right-raw JSR2
	STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-u ( Uclid )
	'U "Bangs 20 "on 20 "Euclidean 20 "rhythm $1
	&func ( addr* -- )

	STH2k
	( step ) #0001 SUB2 ;get-port-left-value JSR2
	( max ) STH2kr INC2 ;get-port-right-value JSR2 DUP #00 EQU ADD STH2
	( frame ADD max SUB 1 ) .timer/frame LDZ2 STHkr #00 SWP ADD2 #0001 SUB2
	( MUL step ) OVRr STHr #00 SWP MUL2
	( % max ) STHkr #00 SWP DIV2k MUL2 SUB2
	( ADD step ) SWPr STHr #00 SWP ADD2
	( bucket GTH= max ) STHr #00 SWP LTH2 #01 NEQ
	( bang if equal ) #fc MUL CHAR-DOT ADD
	STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

@op-v ( variable )
	'V "Reads 20 "and 20 "writes 20 "variable $1
	&func ( addr* -- )

	STH2k
	( key ) #0001 SUB2 ;get-port-left-raw JSR2
	( val ) STH2kr INC2 ;get-port-right-raw JSR2
	DUP CHAR-DOT EQU ,&idle JCN
	OVR ;chrb36 JSR2 ,&save JCN
	( load )
		NIP ;chrb36 JSR2 .variables ADD LDZ STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2 JMP2r
	&save
		SWP ;chrb36 JSR2 .variables ADD STZ POP2r JMP2r
	&idle
		POP2 POP2r

JMP2r

@op-w ( west )
	'W "Moves 20 "westward 20 "or 20 "bangs $1
	&func ( addr* -- )

	STH2k ;data/cells ADD2 LDA ,&self STR
	( wall ) .head/x LDZ #01 SUB #ff EQU ,&collide JCN
	( cell ) STH2kr #0001 SUB2 ;data/cells ADD2 LDA CHAR-DOT NEQ ,&collide JCN
	( write new ) [ LIT &self $1 ] STH2kr #0001 SUB2 ;set-port-raw JSR2
	( erase old ) CHAR-DOT STH2r ;set-port-raw JSR2
	JMP2r
	&collide
	( output ) CHAR-BANG STH2r ;set-port-output JSR2

JMP2r

@op-x ( write )
	'X "Writes 20 "operand 20 "with 20 "offset $1
	&func ( addr* -- )

	STH2k
	( x ) STH2kr #0002 SUB2 ;get-port-left-value JSR2 #00 SWP ADD2
	( y ) STH2kr #0001 SUB2 ;get-port-left-value JSR2 INC #00 SWP #00 .grid/width LDZ MUL2 ADD2
	( val ) STH2r INC2 ;get-port-right-raw JSR2
	( output ) ROT ROT ;set-port-output JSR2

JMP2r

@op-y ( yumper )
	'Y "Outputs 20 "westward 20 "operand $1
	&func ( addr* -- )

	STH2k
	( get above ) #0001 SUB2 ;get-port-left-raw JSR2
	( ignore cable )
	DUP ;chrb36 JSR2 #22 NEQ ,&no-wire JCN
		POP POP2r JMP2r &no-wire
	( skip down )
	STH2r
	&while
		INC2 DUP2 ;data/cells ADD2 LDA ;chrb36 JSR2 #22 EQU
		,&while JCN
	( set below ) ;set-port-output JSR2

JMP2r

@op-z ( lerp )
	'Z "Transitions 20 "operand 20 "to 20 "input $1
	&func ( addr* -- )

	STH2k
	( rate ) #0001 SUB2 ;get-port-left-value JSR2
	( target ) STH2kr INC2 ;get-port-right-raw JSR2
		( get case ) DUP ;ciuc JSR2 ,&case STR
		( to value ) ;chrb36 JSR2
	( val ) STH2kr #00 .grid/width LDZ ADD2 [ ;data/cells ADD2 LDA ;chrb36 JSR2 ]
	( res ) ;lerp JSR2
	( set case ) ;b36chr JSR2 DUP #60 GTH [ LIT &case $1 ] AND #50 SFT SUB
	( output ) STH2r #00 .grid/width LDZ ADD2 ;set-port-output JSR2

JMP2r

( special )

@op-bang ( bang )
	'* "Bangs 20 "neighboring 20 "operands $1
	&func ( char -- )

	POP
	CHAR-DOT .head/addr LDZ2 ;data/cells ADD2 STA

JMP2r

@op-comment ( comment )
	'# "Comments 20 "a 20 "line $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	( bounds )
	#00 .grid/width LDZ .head/x LDZ SUB ADD2
	STH2r INC2
	&loop
		( set lock ) DUP2 #01 ROT ROT ;data/locks ADD2 STA
		( set type if unset )
		DUP2 ;data/types ADD2 LDA ,&skip JCN
			( set type ) DUP2 LOCKED-TYPE ROT ROT ;data/types ADD2 STA
			&skip
		( stop at hash ) DUP2 ;data/cells ADD2 LDA CHAR-HASH EQU ,&end JCN
		INC2 GTH2k ,&loop JCN
	&end
	POP2 POP2

JMP2r

@op-synth ( synth )
	'= "Play 20 "note 20 "with 20 "uxn 20 "synth $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	( channel ) INC2 ;get-port-right-value JSR2 [ ,&ch STR ]
	( octave ) STH2kr INC2 INC2 ;get-port-right-value JSR2
	( note ) STH2kr #0003 ADD2 ;get-port-right-raw JSR2
	( has note ) DUP CHAR-DOT NEQ ,&has-note JCN [ POP2 POP2r JMP2r ] &has-note
	( has bang ) ;get-bang JSR2 ,&is-bang JCN [ POP2 POP2r JMP2r ] &is-bang
	( animate ) IO-TYPE STH2r ;data/types ADD2 STA
	( get note ) ;chrmid JSR2 SWP [ #0c MUL ] ADD
	( play ) .Audio0/pitch [ LIT &ch $1 ] #03 AND #40 SFT ADD DEO

JMP2r

@op-midi ( midi )
	': "Send 20 "a 20 "midi 20 "note $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	( channel ) INC2 ;get-port-right-value JSR2 [ ,&ch STR ]
	( octave ) STH2kr INC2 INC2 ;get-port-right-value JSR2
	( note ) STH2kr #0003 ADD2 ;get-port-right-raw JSR2
	( velocity ) STH2kr #0004 ADD2 ;get-port-right-raw JSR2 [ ,&vel STR ]
	( length ) STH2kr #0005 ADD2 ;get-port-right-value JSR2

	( has note ) OVR CHAR-DOT NEQ ,&has-note JCN [ POP POP2 POP2r JMP2r ] &has-note
	( has bang ) ;get-bang JSR2 ,&is-bang JCN [ POP POP2 POP2r JMP2r ] &is-bang

	( store length ) .voices ,&ch LDR #10 SFT ADD INC STZk POP [ ,&len STR ]

	( animate ) IO-TYPE STH2r ;data/types ADD2 STA

	( get note ) ;chrmid JSR2 SWP [ #0c MUL ] ADD
	( store note ) DUP .voices ,&ch LDR #10 SFT ADD STZ
	( get velocity ) [ LIT &vel $1 ]
		DUP CHAR-DOT NEQ ,&normalize JCN
			( default to max ) POP #7f ,&continue JMP
		&normalize
		;raw-to-b128 JSR2 &continue SWP
	( get channel ) [ LIT &ch $1 ]

	( note on )
	( channel ) DUP .Console/write DEO
	( note ) OVR .Console/write DEO
	( velocity ) ROT .Console/write DEO

	.signal/midi LDZk INC SWP STZ

	( note off immediately if 0 length )
	[ LIT &len $1 ] #00 NEQ ,&done JCN
		( channel ) .Console/write DEO
		( note ) .Console/write DEO
		( off ) #00 .Console/write DEO
		JMP2r
	&done
	POP2

JMP2r

@op-pitch ( pitch )
	'; "Send 20 "a 20 "raw 20 "pitch 20 "byte $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	( octave ) INC2 ;get-port-right-value JSR2
	( note ) STH2kr INC2 INC2 ;get-port-right-raw JSR2
	( has note ) DUP CHAR-DOT NEQ ,&has-note JCN [ POP2 POP2r JMP2r ] &has-note
	( has bang ) ;get-bang JSR2 ,&is-bang JCN [ POP2 POP2r JMP2r ] &is-bang
	( animate ) IO-TYPE STH2r ;data/types ADD2 STA
	( get note ) ;chrmid JSR2 SWP [ #0c MUL ] ADD .Console/write DEO

JMP2r

@op-byte ( byte )
	'/ "Send 20 "a 20 "raw 20 "hexadecimal 20 "byte $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	( hn ) INC2 ;get-port-right-value JSR2
	( ln ) STH2kr INC2 INC2 ;get-port-right-value JSR2
	( has bang ) ;get-bang JSR2 ,&is-bang JCN [ POP2 POP2r JMP2r ] &is-bang
	( animate ) IO-TYPE STH2r ;data/types ADD2 STA
	#0f AND SWP #0f AND #40 SFT ADD .Console/write DEO

JMP2r

@op-self ( self )
	'$ "Load 20 "orca 20 "file $1
	&func ( char -- )

	POP
	.head/addr LDZ2 STH2k
	&while
		INC2 DUP2 ;get-port-right-raw JSR2 LIT '. NEQ ,&while JCN
	POP2
	( has bang ) ;get-bang JSR2 ,&is-bang JCN [ POP2r JMP2r ] &is-bang
	.head LDZ2 INC STH2kr ;get-word JSR2 ;inject-file JSR2
	( animate ) IO-TYPE STH2r ;data/types ADD2 STA

JMP2r
