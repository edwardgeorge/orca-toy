@op-table
	&docs
	=op-a/? =op-b/? =op-c/? =op-d/? =op-e/? =op-f/? =op-g/? =op-h/?
	=op-i/? =op-j/? =op-k/? =op-l/? =op-m/? =op-n/? =op-o/? =op-p/?
	=op-q/? =op-r/? =op-s/? =op-t/? =op-u/? =op-v/? =op-w/? =op-x/?
	=op-y/? =op-z/?
	=op-bang/? =op-comment/? =op-synth/?
	=op-midi/? =op-pitch/? =op-byte/? =op-self/?

( add )
@op-a-lc get-bang ?&* POP2 JMP2r &* @op-a

	STH2k
	( set type ) .types/op STH2kr write-type
	( a ) get-port-left1-value
	( b ) STH2kr get-port-right1-raw
		( case-val ) DUP ciuc ,&case STR chrb36
	( res ) ADD
	[ LIT &case $1 ] set-case STH2r !set-port-output-below
	&? "A "Outputs 20 "sum 20 "of 20 "inputs $1

( subtract )
@op-b-lc get-bang ?&* POP2 JMP2r &* @op-b

	STH2k
	( set type ) .types/op STH2kr write-type
	( a ) get-port-left1-value
	( b ) STH2kr get-port-right1-raw
		( case-val ) DUP ciuc ,&case STR chrb36
	( res ) SUB DUP #80 LTH ?&bounce #24 SWP SUB &bounce
	[ LIT &case $1 ] set-case STH2r !set-port-output-below
	&? "B "Outputs 20 "difference 20 "of 20 "inputs $1

( clock )
@op-c-lc get-bang ?&* POP2 JMP2r &* @op-c

	STH2
	( set type ) .types/op STH2kr write-type
	.timer/frame LDZ2
	#00 ( rate ) STH2kr get-port-left1-value
		( min1* ) EQUk ADD
		DIV2
	#00 ( mod ) STH2kr get-port-right1-raw
			( case-val ) DUP ciuc ,&case STR chrb36
			( min1* ) EQUk ADD
		( mod2 ) [ DIV2k MUL2 SUB2 ] NIP
	[ LIT &case $1 ] set-case STH2r !set-port-output-below
	&? "C "Outputs 20 "modulo 20 "of 20 "frame $1

( delay )
@op-d-lc get-bang ?&* POP2 JMP2r &* @op-d

	STH2
	( set type ) .types/op STH2kr write-type
	.timer/frame LDZ2
		#00 ( rate* ) STH2kr get-port-left1-value ( min1* ) EQUk ADD
		#00 ( mod* ) STH2kr get-port-right1-value ( min1* ) EQUk ADD
			MUL2
		( mod2 ) [ DIV2k MUL2 SUB2 ] #0000 EQU2
		( bang ) [ LIT2 "*. ] ROT [ JMP SWP POP ]
	STH2r !set-port-output-below
	&? "D "Bangs 20 "on 20 "modulo 20 "of 20 "frame $1

( east )
@op-e-lc get-bang ?&* POP2 JMP2r &* @op-e

	STH2k
	( set type ) .types/op STH2kr write-type
	read-cell ,&self STR
	( wall ) .head/x LDZ INC .grid/width LDZ EQU ?&collide
	( cell ) STH2kr INC2 read-cell LIT ". NEQ ?&collide
	( new ) [ LIT &self $1 ] STH2kr INC2 set-port-raw
	LIT ". STH2r !set-port-raw
	&collide
	LIT "* STH2r !set-port-output
	&? "E "Moves 20 "eastward 20 "or 20 "bangs $1

( if )
@op-f-lc get-bang ?&* POP2 JMP2r &* @op-f

	STH2k
	( set type ) .types/op STH2kr write-type
	( a ) get-port-left1-raw
	( b ) STH2kr get-port-right1-raw
	( bang ) EQU [ LIT2 "*. ] ROT [ JMP SWP POP ]
	STH2r !set-port-output-below
	&? "F "Bangs 20 "if 20 "inputs 20 "are 20 "equal $1

( generator )
@op-g-lc get-bang ?&* POP2 JMP2r &* @op-g

	STH2k
	( set type ) .types/op STH2kr write-type
	( x ) STH2kr #0003 SUB2 get-port-left-value
		( load ) #00 SWP ADD2
	( y ) STH2kr #0002 SUB2 get-port-left-value
		( load ) #00 SWP INC2 [ #00 .grid/width LDZ MUL2 ] ADD2
	,&save STR2
	( len ) STH2kr get-port-left1-value ( min1 ) DUP #00 EQU ADD
	#00
	&l
		( load ) #00 OVR STH2kr INC2 ADD2 get-port-right-raw
		( save ) OVR #00 SWP [ LIT2 &save $2 ] ADD2 set-port-output
		INC GTHk ?&l
	POP2
	POP2r

JMP2r
	&? "G "Writes 20 "operands 20 "with 20 "offset $1

( hold )
@op-h-lc get-bang ?&* POP2 JMP2r &* @op-h

	STH2k
	( set type ) .types/op STH2kr write-type
	( cell ) #00 .grid/width LDZ ADD2 read-cell
	STH2r !set-port-output-below
	&? "H "Holds 20 "southward 20 "operand $1

( increment )
@op-i-lc get-bang ?&* POP2 JMP2r &* @op-i

	STH2k
	( set type ) .types/op STH2kr write-type
	( step ) get-port-left1-value
	( mod ) STH2kr get-port-right1-raw
		( case-val ) DUP ciuc ,&case STR chrb36
		( min1 ) DUP #00 EQU ADD
	( res ) SWP STH2kr #00 .grid/width LDZ ADD2 read-cell chrb36 ADD SWP
	( MOD ) [ DIVk MUL SUB ]
	[ LIT &case $1 ] set-case STH2r !set-port-output-below
	&? "I "Increments 20 "southward 20 "operand $1

( jumper )
@op-j-lc get-bang ?&* POP2 JMP2r &* @op-j

	STH2k
	( set type ) .types/op STH2kr write-type
	( get above ) #00 .grid/width LDZ SUB2 get-port-left-raw
	( ignore cable )
	DUP chrb36 #13 NEQ ?&no-wire
		POP POP2r JMP2r &no-wire
	( skip down )
	STH2r
	&while
		#00 .grid/width LDZ ADD2 DUP2 read-cell chrb36 #13 EQU
		?&while
	( set below ) !set-port-output
	&? "J "Outputs 20 "northward 20 "operand $1

( konkat )
@op-k-lc get-bang ?&* POP2 JMP2r &* @op-k

	STH2k
	( set type ) .types/op STH2kr write-type
	get-port-left1-value #00
	&l
		#00 OVR STH2kr INC2 ADD2 STH2k get-port-right-raw
		DUP LIT ". EQU ?&skip
			( load ) DUP chrb36 .variables ADD LDZ
			( save ) STH2kr set-port-output-below
			&skip
		POP
		POP2r
		INC GTHk ?&l
	POP2
	POP2r

JMP2r
	&? "K "Reads 20 "multiple 20 "variables $1

( lesser )
@op-l-lc get-bang ?&* POP2 JMP2r &* @op-l

	STH2k
	( set type ) .types/op STH2kr write-type
	( a ) get-port-left1-value
	( b ) STH2kr get-port-right1-raw
		( case-val ) DUP ciuc ,&case STR chrb36
	( res ) [ LTHk JMP SWP POP ]
	[ LIT &case $1 ] set-case STH2r !set-port-output-below
	&? "L "Outputs 20 "smallest 20 "of 20 "inputs $1

( multiply )
@op-m-lc get-bang ?&* POP2 JMP2r &* @op-m

	STH2k
	( set type ) .types/op STH2kr write-type
	( a ) get-port-left1-value
	( b ) STH2kr get-port-right1-raw
		( case-val ) DUP ciuc ,&case STR chrb36
	( res ) MUL
	[ LIT &case $1 ] set-case STH2r !set-port-output-below
	&? "M "Outputs 20 "product 20 "of 20 "inputs $1

( north )
@op-n-lc get-bang ?&* POP2 JMP2r &* @op-n

	STH2k
	( set type ) .types/op STH2kr write-type
	read-cell ,&self STR
	( wall ) .head/y LDZ #01 SUB #ff EQU ?&collide
	( cell ) STH2kr #00 .grid/width LDZ SUB2 read-cell LIT ". NEQ ?&collide
	( write new ) [ LIT &self $1 ] STH2kr #00 .grid/width LDZ SUB2 set-port-raw
	( erase old ) LIT ". STH2r !set-port-raw
	&collide
	LIT "* STH2r !set-port-output
	&? "N "Moves 20 "Northward 20 "or 20 "bangs $1

( read )
@op-o-lc get-bang ?&* POP2 JMP2r &* @op-o

	STH2k
	( set type ) .types/op STH2kr write-type
	( x ) STH2kr #0002 SUB2 get-port-left-value INC #00 SWP ADD2
	( y ) STH2kr get-port-left1-value #00 SWP #00 .grid/width LDZ MUL2 ADD2
	( val ) get-port-right-raw
	STH2r !set-port-output-below
	&? "O "Reads 20 "operand 20 "with 20 "offset $1

( push )
@op-p-lc get-bang ?&* POP2 JMP2r &* @op-p

	STH2k
	( set type ) .types/op STH2kr write-type
	( key ) #0002 SUB2 get-port-left-value
	( len ) STH2kr get-port-left1-value ( min1 ) DUP #00 EQU ADD
	#00
	&l
		#00 OVR STH2kr #00 .grid/width LDZ ADD2 ADD2 STH2
		( lock ) #01 STH2kr write-lock
		( type ) .types/locked STH2r write-type
		INC GTHk ?&l
	POP
	( read ) STH2kr get-port-right1-raw
	ROT ROT
	( MOD ) [ DIVk MUL SUB ] #00 SWP STH2r #00 .grid/width LDZ ADD2 ADD2
		!set-port-output
	&? "P "Writes 20 "eastward 20 "operand $1

( query )
@op-q-lc get-bang ?&* POP2 JMP2r &* @op-q

	STH2k
	( set type ) .types/op STH2kr write-type
	( x ) STH2kr #0003 SUB2 get-port-left-value
		( load ) #00 SWP INC2 ADD2
	( y ) STH2kr #0002 SUB2 get-port-left-value
		( load ) #00 SWP [ #00 .grid/width LDZ MUL2 ] ADD2
	,&load STR2
	( len ) STH2kr get-port-left1-value ( min1 ) DUP #00 EQU ADD
		( save ) #00 OVR STH2kr #00 .grid/width LDZ ADD2 SWP2 SUB2 INC2 ,&save STR2
	#00
	&l
		( load ) #00 OVR [ LIT2 &load $2 ] ADD2 get-port-right-raw
		( save ) OVR #00 SWP [ LIT2 &save $2 ] ADD2 set-port-output
		INC GTHk ?&l
	POP2
	POP2r

JMP2r
	&? "Q "Reads 20 "operands 20 "with 20 "offset $1

( random )
@op-r-lc get-bang ?&* POP2 JMP2r &* @op-r

	STH2k
	( set type ) .types/op STH2kr write-type
	( a-min ) get-port-left1-value
	( b-max ) STH2kr get-port-right1-raw
		( case-val ) DUP ciuc ,&case STR chrb36
		( min1 ) DUP #00 EQU ADD
	( mod ) OVR SUB prng ADD SWP ( min1 ) DUP #00 EQU ADD
	( MOD ) [ DIVk MUL SUB ] ADD
	[ LIT &case $1 ] set-case STH2r !set-port-output-below
	&? "R "Outputs 20 "random 20 "value $1

( south )
@op-s-lc get-bang ?&* POP2 JMP2r &* @op-s

	STH2k
	( set type ) .types/op STH2kr write-type
	read-cell ,&self STR
	( wall ) .head/y LDZ INC .grid/height LDZ EQU ?&collide
	( cell ) STH2kr #00 .grid/width LDZ ADD2 read-cell LIT ". NEQ ?&collide
	( write new ) [ LIT &self $1 ] STH2kr #00 .grid/width LDZ ADD2 set-port-raw
	( erase old ) LIT ". STH2r !set-port-raw
	&collide
	LIT "* STH2r !set-port-output
	&? "S "Moves 20 "southward 20 "or 20 "bangs $1

( track )
@op-t-lc get-bang ?&* POP2 JMP2r &* @op-t

	STH2k
	( set type ) .types/op STH2kr write-type
	( key ) #0002 SUB2 get-port-left-value
	( len ) STH2kr get-port-left1-value ( min1 ) DUP #00 EQU ADD
	#00
	&l
		#00 OVR STH2kr INC2 ADD2 STH2
		( lock ) #01 STH2kr write-lock
		( type ) .types/locked STH2r write-type
		INC GTHk ?&l
	POP
	( read )
	( MOD ) [ DIVk MUL SUB ] #00 SWP STH2kr INC2 ADD2 get-port-right-raw
	STH2r !set-port-output-below
	&? "T "Reads 20 "eastward 20 "operand $1

( Uclid )
@op-u-lc get-bang ?&* POP2 JMP2r &* @op-u

	STH2k
	( set type ) .types/op STH2kr write-type
	( step ) get-port-left1-value
	( max ) STH2kr get-port-right1-value ( min1 ) DUP #00 EQU ADD STH2
	( frame ADD max SUB 1 ) .timer/frame LDZ2 STHkr #00 SWP ADD2 #0001 SUB2
	( MUL step ) OVRr STHr #00 SWP MUL2
	( % max ) STHkr #00 SWP
	( mod2 ) [ DIV2k MUL2 SUB2 ]
	( ADD step ) SWPr STHr #00 SWP ADD2
	( bucket GTH= max ) STHr #00 SWP LTH2 #01 NEQ
	( bang if equal ) #fc MUL LIT ". ADD
	STH2r !set-port-output-below
	&? "U "Bangs 20 "on 20 "Euclidean 20 "rhythm $1

( variable )
@op-v-lc get-bang ?&* POP2 JMP2r &* @op-v

	STH2k
	( set type ) .types/op STH2kr write-type
	( key ) get-port-left1-raw
	( val ) STH2kr get-port-right1-raw
	DUP LIT ". EQU ?&idle
	OVR chrb36 ?&save
	( load )
		NIP chrb36 .variables ADD LDZ STH2r #00 .grid/width LDZ ADD2 !set-port-output
	&save
		SWP chrb36 .variables ADD STZ POP2r JMP2r
	&idle
		POP2 POP2r

JMP2r
	&? "V "Reads 20 "and 20 "writes 20 "variable $1

( west )
@op-w-lc get-bang ?&* POP2 JMP2r &* @op-w

	STH2k
	( set type ) .types/op STH2kr write-type
	read-cell ,&self STR
	( wall ) .head/x LDZ #01 SUB #ff EQU ?&collide
	( cell ) STH2kr #0001 SUB2 read-cell LIT ". NEQ ?&collide
	( write new ) [ LIT &self $1 ] STH2kr #0001 SUB2 set-port-raw
	( erase old ) LIT ". STH2r !set-port-raw
	&collide
	LIT "* STH2r !set-port-output
	&? "W "Moves 20 "westward 20 "or 20 "bangs $1

( write )
@op-x-lc get-bang ?&* POP2 JMP2r &* @op-x

	STH2k
	( set type ) .types/op STH2kr write-type
	( x ) STH2kr #0002 SUB2 get-port-left-value #00 SWP ADD2
	( y ) STH2kr get-port-left1-value INC #00 SWP #00 .grid/width LDZ MUL2 ADD2
	( val ) STH2r get-port-right1-raw
	ROT ROT !set-port-output
	&? "X "Writes 20 "operand 20 "with 20 "offset $1

( yumper )
@op-y-lc get-bang ?&* POP2 JMP2r &* @op-y

	STH2k
	( set type ) .types/op STH2kr write-type
	( get above ) get-port-left1-raw
	( ignore cable )
	DUP chrb36 #22 NEQ ?&no-wire
		POP POP2r JMP2r &no-wire
	( skip down )
	STH2r
	&while
		INC2 DUP2 read-cell chrb36 #22 EQU
		?&while
	( set below ) !set-port-output
	&? "Y "Outputs 20 "westward 20 "operand $1

( lerp )
@op-z-lc get-bang ?&* POP2 JMP2r &* @op-z

	STH2k
	( set type ) .types/op STH2kr write-type
	( rate ) get-port-left1-value
	( target ) STH2kr get-port-right1-raw
		( case-val ) DUP ciuc ,&case STR chrb36
	( val ) STH2kr #00 .grid/width LDZ ADD2 read-cell chrb36
	( res ) lerp
	[ LIT &case $1 ] set-case STH2r !set-port-output-below
	&? "Z "Transitions 20 "operand 20 "to 20 "input $1

(
@|special )

( bang )
@op-bang

	LIT ". ROT ROT

!write-cell
	&? "* "Bangs 20 "neighboring 20 "operands $1

( comment )
@op-comment

	STH2k
	( set itself )
	.types/comment STH2kr write-type
	( get edge )
	#00 .grid/width LDZ .head/x LDZ SUB ADD2
	STH2r INC2
	&l
		( set lock ) STH2k #01 STH2r write-lock
		( set type if unset )
		DUP2 read-type ?&skip
			( set type ) STH2k .types/comment STH2r write-type
			&skip
		( stop at hash ) DUP2 read-cell LIT "# EQU ?&end
		INC2 GTH2k ?&l
	&end
	POP2 POP2

JMP2r
	&? "# "Comments 20 "a 20 "line $1

( synth )
@op-synth

	STH2k
	( channel ) get-port-right1-value [ ,&ch STR ]
	( octave ) STH2kr INC2 get-port-right1-value
	( note ) STH2kr #0003 ADD2 get-port-right-raw
	( has note ) DUP LIT ". NEQ ?&has-note [ POP2 POP2r JMP2r ] &has-note
	( has bang ) get-bang ?&is-bang [ POP2 POP2r JMP2r ] &is-bang
	( animate ) .types/io STH2r write-type
	( get note ) chrmid SWP [ #0c MUL ] ADD
	( play ) .Audio0/pitch [ LIT &ch $1 ] #03 AND #40 SFT ADD DEO

JMP2r
	&? "= "Play 20 "note 20 "with 20 "uxn 20 "synth $1

( midi )
@op-midi

	STH2k
	( channel ) get-port-right1-value [ ,&ch STR ]
	( octave ) STH2kr INC2 get-port-right1-value
	( note ) STH2kr #0003 ADD2 get-port-right-raw
	( velocity ) STH2kr #0004 ADD2 get-port-right-raw [ ,&vel STR ]
	( length ) STH2kr #0005 ADD2 get-port-right-value

	( has note ) OVR LIT ". NEQ ?&has-note [ POP POP2 POP2r JMP2r ] &has-note
	( has bang ) get-bang ?&is-bang [ POP POP2 POP2r JMP2r ] &is-bang

	( store length ) .voices ,&ch LDR DUP ADD ADD INC STZk POP [ ,&len STR ]

	( animate ) .types/io STH2r write-type

	( get note ) chrmid SWP [ #0c MUL ] ADD
	( store note ) DUP .voices ,&ch LDR DUP ADD ADD STZ
	( get velocity ) [ LIT &vel $1 ]
		DUP LIT ". NEQ ?&normalize
			( default to max ) POP #7f ,&continue JMP
		&normalize
		base128 &continue SWP
	( get channel ) [ LIT &ch $1 ]

	( note on )
	( channel ) DUP .Console/write DEO
	( note ) OVR .Console/write DEO
	( velocity ) ROT .Console/write DEO

	.signal/midi LDZk INC SWP STZ

	( note off immediately if 0 length )
	[ LIT &len $1 ] #00 NEQ ?&done
		( channel ) .Console/write DEO
		( note ) .Console/write DEO
		( off ) #00 .Console/write DEO
		JMP2r
	&done
	POP2

JMP2r
	&? ": "Send 20 "a 20 "midi 20 "note $1

( pitch )
@op-pitch

	STH2k
	( octave ) get-port-right1-value
	( note ) STH2kr INC2 get-port-right1-raw
	( has note ) DUP LIT ". NEQ ?&has-note [ POP2 POP2r JMP2r ] &has-note
	( has bang ) get-bang ?&is-bang [ POP2 POP2r JMP2r ] &is-bang
	( animate ) .types/io STH2r write-type
	( get note ) chrmid SWP [ #0c MUL ] ADD .Console/write DEO

JMP2r
	&? "; "Send 20 "a 20 "raw 20 "pitch 20 "byte $1

( byte )
@op-byte

	STH2k
	( hn ) get-port-right1-value
	( ln ) STH2kr INC2 get-port-right1-value
	( has bang ) get-bang ?&is-bang [ POP2 POP2r JMP2r ] &is-bang
	( animate ) .types/io STH2r write-type
	#0f AND SWP #0f AND #40 SFT ADD .Console/write DEO

JMP2r
	&? "/ "Send 20 "a 20 "raw 20 "hexadecimal 20 "byte $1

( self )
@op-self

	STH2k
	&while
		INC2 DUP2 get-port-right-raw LIT ". NEQ ?&while
	POP2
	( has bang ) get-bang ?&is-bang [ POP2r JMP2r ] &is-bang
	.head LDZ2 INC STH2kr get-word inject-file
	( animate ) .types/io STH2r

!write-type
	&? "$ "Load 20 "orca 20 "file $1

( null )
@op-null

	POP2

JMP2r

~src/manifest.tal

